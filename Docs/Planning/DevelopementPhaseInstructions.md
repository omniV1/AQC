Project Requirements Template Submission

Look back at what has been done so far in the project and make changes/modify what was done in the past. It is important to continually review the project plan to address issues and oversights that are discovered.

Milestone 4: Development Phase (Coding and Testing)

Coding Objective: The main objective of the development phase is to build the project code and create the documentation based on the requirements and analysis decisions. This phase transforms the design documents into an executable program. System entities, such as objects, data tables, classes, and the like are developed. These entities are then gathered and connected together (integrated) to create a working application. The application is placed on a staging server for testing. Code reviews are generally part of the development phase. Refer to the “Test Case Template and the Traceability Matrix Template,” located in the Class Resources.

Coding Deliverables: Submission of the Implementation Plan, Functional Requirements Mapping (i.e., Traceability Matrix), Module Test Cases, Source Code Listing, and Application Demonstration. Refer to the information below for additional details on each section of the Development Phase.

Coding Special Note: Depending on the project, portions of this milestone may not be applicable. In cases like these, work with the instructor to determine the components of the project that may replace this step. The instructor will determine what documentation is needed and how this documentation will be assessed. If major portions of the project consist of theoretical components (e.g., algorithm design), coding might be substituted with mathematical proof and analysis of correctness, or other mathematical treatment of the subject—in consultation with the project advisor.

Implementation Plan

The implementation plan provides a detailed outline of activities necessary to ensure that delivery of the planned user stories for the milestone assignment. This course does not specify which planning delivery methodology or tools you are required to use in your implementation plan. It is recommended you seek advice from your mentor or the instructor. The following are some suggestions you can follow for your implementation plan.
1)	Use a formal methodology, such Agile Scrum or Kanban.
2)	Planning tools could include but not limited to Microsoft Excel or Word template, boards on monday.com, boards and reports on notion.so, scrum burn down templates, and more.
3)	At a minimum your implementation plan should include the follow elements:

Use Case or User Story	List of detailed Development Tasks	Estimate (hrs.)	Actual (hrs.)	Percent Complete

	Percent of User Stories complete for this iteration:
	Percent of User Stories complete for entire project:

Mapping of Functional Requirements 

Ensure that all functional requirements have been satisfied by creating a mapping for each requirement to the technical Architecture Plan, and code module(s) or function(s) that satisfies the requirement, and the test cases used to test the requirement. This is referred to the Traceability and a template can be found in the Class Resources.

Example

(Use Case/User Story)
Monthly bill sent by email	(Architecture Plan)
Page or section where designed	(Code Module)
Class and Method where implemented	(Test Case)
Test Case number from the Test Plan

Source Code Listing
Provide a listing of the source code for the project. Include a brief description of all classes and files. Code should follow industry best practices, formatting, and comment style appropriate for the programming language.



Test Plan and Test Cases
Develop test cases for all modules. Test modules as part of development process and continually revise code as necessary. A Test Plan and Test Case template can be found in the Class Resources.

Example of Test Case Listing

Test Case Name: 
Priority: 
Module:
Test Objective: 
						
Step		Test Name	Test Steps	Test Data	Expected Results	Test Pass/Fail
1						
2						
3						

Testing Objective: The testing phase ensures the application functions as requested and encompasses three testing stages: Component testing, requirements testing, and acceptance testing.
In all testing stages, defects are identified and returned to the development/coding phase for correction. 

Testing Deliverable: Submission of the Unit and Integration Test Plans, including the Test Case Specification Documents and Test Analysis Approval Form.

 
Refer to the information below for additional details on each section of the Testing Phase.

Testing Special Note: Depending on the project, portions of this milestone may not be applicable. In cases like these, work with the instructor to determine the components of the project that may replace this step. The instructor will determine what documentation is needed and how this documentation will be assessed. If major portions of the project are not code, the testing might consist, for example, of proof by induction that an algorithm works the way it is envisioned – consult the project advisor.

Component Testing: During component testing, all objects are tested to ensure they work together as specified by the physical design. If issues are discovered, the project returns to the implementation phase for corrective action.

Unit Testing: Test each module individually. Detailed scripts are used in the development and test phases for evaluating the completeness and correctness of the smallest parts of the system and the components created from those parts. Also included are test scripts that are high-level and more focused on processes.

Requirements Testing: Once the components are tested and the system operates as designed, the application is tested against the requirements gathered in the requirements phase of development using the Test Cases defined in the Test Plan. Ensure that all requirements map to test scenarios. 

A test requirement identifies the "WHAT" of testing. 

What needs to be tested AND what are you going to validate about it?

A test requirement includes normal and error conditions. It covers business rules, functionality, and non-functional standards.

Requirements Testing Examples:
Validate that you can insert an entry.
Validate that insertion fails if entry already present.
Validate that insertion fails if table already full.
Validate that you can insert an entry to an empty table (initial).
 

System Testing: System testing verifies that all components of the functional business requirements, business processes, data flows, and other system criteria are met. The developer(s) tests specific end-to-end relevant processes until the complete application environment mimics the intended use upon release. 

There are three key parts to creating a system test plan. The first part is the system test plan overview, which provides basic background information about the system test such as the date, system test objectives and goals, and system test duration. The second part is the system test scope and resources, which provides details of the system testing scope. 

For example, the features that need to be tested: __; Features that is not to be tested: __; System test resources: __ etc.

The final part is the system test strategy, which demonstrates how the developer will perform the system test. 

For example, the system test procedures: __; The system test environment: __; System test tools required: __; System test criteria: __.
Entry Criteria for System Testing: 
Unit testing should be finished
Integration of modules should be fully integrated
As per the specification document, software development is completed
Testing environment is available for testing (similar to Staging environment)

Acceptance Testing (if applicable): The User Acceptance Test (UAT) validates that the system, as a whole, meets mutually agreed-upon requirements. UAT is completed by end-users of the application and occurs before a client or customer accepts the new system.

 

Application Demonstration

Provide a short screencast (5-10 minutes), per GCU policies used in previous classes, that demonstrates functionality that is working up to this point in the project.

